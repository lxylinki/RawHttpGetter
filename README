To execute the code:

(optional: ./restore_iptable to reset previous session if run multiple times)

./set_iptable
sudo ./rawhttpget [URL] or ./get_txt (which is a fully working case)


High level approach:
Read RFCs for IP and TCP headers, customize functions from web tutorials, test towards CCIS hosted machines. 



Functionalities implemented and not yet implemented (marked with '>'):

1. Set correct iptable rules.

2. Create a correctly named file in the current directory.

3. Setting the correct version, header length and total length, protocol identifier, and checksum in each outgoing packet.

4. Filtering the incoming packets to isolate the ones that belong to your program.

5. Correctly set the source and destination IP in each outgoing packet. 

>6. Check the validity of IP headers from the remote server.

7. Generate correct checksums for outgoing packets. 

8. Select a valid local port to send traffic on.

9. Perform the three-way handshake.

10. Correctly handle sequence and acknowledgement numbers. 

11. Basic timeout functionality (if a packet is not ACKed within 1 minute, assume the packet is lost and retransmit it).

12. Receive out-of-order incoming packets and put them back into the correct order.

13. Identify and discard duplicate packets.

14. Implement a basic congestion window: 
start with cwnd=1, and increment the cwnd after each succesful ACK, up to a fixed maximum of 1000 (e.g. cwnd must be <=1000 at all times). If your program observes a packet drop or a timeout, reset the cwnd to 1.

>15. If your program does not receive any data from the remote server for three minutes, your program can assume that the connection has failed, print an error message and exit. 

16. Correctly handle connection teardown.


Challenges:
Socket timeout handling, IP and TCP headers encoding & parsing. 


